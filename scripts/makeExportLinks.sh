#!/bin/bash --noprofile
# This file is protected by Copyright. Please refer to the COPYRIGHT file
# distributed with this source distribution.
#
# This file is part of OpenCPI <http://www.opencpi.org>
#
# OpenCPI is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# OpenCPI is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with this program. If not, see <http://www.gnu.org/licenses/>.


# Populate the exports tree with the links that will be needed for later build stages,
# and links that are only dependent on stable, non-generated source files etc.
# we will initially populate a exports.temp directory and if all is well, we will
# rename it to exports and remove the previous one.
#
# This script is done in the context of a particular target, as its first argument.
#
# This script must be tolerant of things not existing, and it is called repeatedly as
# more things get built
# We use the term "facilities" as basic subdirectories where stuff gets built.
# This script does not care or drive how these things get built.
# It only needs the Facilities file, if present.
#
# These are the categories of links we will create.
# Libraries generated by library facilities
# Drivers generated by driver facilities
#   FIXME: put drivers in a separate place and distinguish them from libraries? to avoid name collisions?
# Main programs generated by library facilities

# The sorry state of POSIX/BSD/LINUX/MACOS command compatibility
extended=$(if [ `uname -s` = Darwin ]; then echo -E .; else echo . -regextype posix-extended; fi)

# match_pattern: Find the files that match the pattern:
#  - use default bash glob, and also
#  - avoids looking at ./exports/
#  - consolidate files that are hard or soft linked into single (first in inode sort order) file
#  - following links so that patterns can match against the link path
function match_pattern {
  local arg=$1
  if [[ $arg == \|* ]]; then
    arg=$(echo "$arg" | sed 's=^|\(.*\)$=./\1=') # add ./ prefix for find command, replacing |
    arg=$(find $extended -regex "$arg")   # expand using find with extended regex
  else
    arg="$(echo $arg)" # normal shell glob behavior
  fi
  local matches=$(shopt -s nullglob; for i in $arg; do echo $i | grep -v '#$' | grep -v '^./exports/'; done)
  [ -z "$matches" ] && return 0
  ls -L -i -d $matches 2>/dev/null | sort -n -b -u | sed 's/^ *[0-9]* *//;s/^\.\///'
}

# Check the exclusion in $1 against the path in $2
# The exclusion might be shorter than the path
# No wild carding here (yet)
function match_filter {
  # echo match_filter $1 $2
  local -a edirs pdirs
  edirs=(${1//\// })
  pdirs=(${2//\// })
  for ((i=0; i<${#pdirs[*]}; i++)); do
    # echo MF:$i:${edirs[$i]}:${pdirs[$i]}:
    if [[ "${edirs[$i]}" == "" ]]; then
      return 0
    elif [[ "${edirs[$i]}" == target-* ]]; then
      if [[ "${pdirs[$i]}" != target-* ]]; then
	return 1
      fi
    elif [[ "${edirs[$i]}" != "${pdirs[$i]}" ]]; then
      return 1
    fi
  done 
  return 0   
}

function make_relative_link {
  # echo make_relative_link $1 $2
  # Figure out what the relative prefix should be
  up=$(echo $2 | sed 's-[^/]*$--' | sed 's-[^/]*/-../-g')
  link=${up}$1
  if [ -L $2 ]; then
    L=$(ls -l $2|sed 's/^.*-> *//')
    if [ "$L" = "$link" ]; then
      # echo Symbolic link already correct from $2 to $1.
      return 0
    else
      echo Symbolic link wrong from $2 to $1 wrong \(was $L\), replacing it.
      rm $2
    fi
  elif [ -e $2 ]; then
    if [ -d $2 ]; then
      echo Link $2 already exists, as a directory.
    else
      echo Link $2 already exists, as a regular file.
    fi
    echo '   ' when trying to link to $1
    exit 1
  fi
  mkdir -p $(dirname $2)
  # echo ln -s $link $2
  ln -s $link $2
}

# link to source ($1) from link($2) if neither are filtered
# $3 is the type of object
# exclusions can be filtered by source or target
function make_filtered_link {
  local e;
  local -a edirs
  for e in $exclusions; do
    declare -a both=($(echo $e | tr : ' '))
    # echo EXBOTH=${both[0]}:${both[1]}:$3:$1:$2
    [ "${both[1]}" != "" -a "${both[1]}" != "$3" ] && continue
    # echo EXBOTH1=${both[0]}:${both[1]}:$3:$1:$2
    edirs=(${both[0]/\// })
    if [ ${edirs[0]} = exports ]; then
       if match_filter ${both[0]} $2; then return; fi
    else
       if match_filter ${both[0]} $1; then return; fi
    fi
  done
  # No exclusions matched.  Make the directory for the link
  make_relative_link $1 $2
}

if test "$*" = ""; then
  echo "Usage is: makeExportLinks.sh <target> <prefix>"
  echo "This script takes two arguments:"
  echo "  <target> in the form of <os>-<version>-<machine>[/mm], e.g. linux-c6-x86_64"
  echo "    It is commonly used with the value of the OCPI_TARGET_DIR environment variable."
  echo "  <prefix> is the prefix for all libraries in this project."
  echo '    For the CDK/core project, it is "ocpi_"'
  echo '    It is typically the project prefix followed by underscore'
  echo 'This script is typically used internally by "make exports"'
  echo 'It is designed to be run repeatedly, making links to whatever exists.'
  echo 'Thus it is run several times during the build process.'
  exit 1
fi
if [ "$1" = "-v" -o "$OCPI_EXPORTS_VERBOSE" = 1 ]; then
  verbose=yes
  [ "$1" = "-v" ] && shift
  [ -n "$verbose" ] && echo Setting verbose mode.
fi
os=$(echo $1 | sed 's/^\([^-]*\).*$/\1/')
dylib=$(if [ "$os" = macos ]; then echo dylib; else echo so; fi)
set -e
#rm -r -f exports
mkdir -p exports
set -f
[ -n "$verbose" ] && echo Collecting exclusions
exclusions=$(test -f Project.exports && grep '^[ 	]*-' Project.exports | sed 's/^[ 	]*-[ 	]*\([^ 	#]*\)[ 	]*\([^ 	#]*\).*$/\1:\2/') || true
[ -n "$verbose" ] && echo Collecting additions
additions=$(test -f Project.exports && grep '^[ 	]*+' Project.exports | sed 's/^[ 	]*+[ 	]*\([^ 	#]*\)[ 	]*\([^ 	#]*\).*$/\1:\2/') || true
set +f
facilities=$(test -f Project.exports &&  grep -v '^[ 	]*[-+#]' Project.exports | grep -v '^[ 	]*$' | \
  sed 's/^[ 	]*\([^ 	#]*\)[ 	]*\([^ 	#]*\).*$/\1:\2/') || true
[ -n "$3" -a "$3" != "-" ] && \
  if [[ "$3" != `cat exports/project-package-id 2>/dev/null` ]]; then
    echo "$3" > exports/project-package-id;
  fi
if [ -d imports ]; then
  make_filtered_link imports exports/imports main
fi
for ff in $facilities; do
  declare -a fboth=($(echo $ff | tr : ' '))
  f=${fboth[0]}
  if [ -n "${fboth[1]}" ]; then
    libname=${fboth[1]}
  else
    libname=$(basename $f)
  fi
  if [ "$1" == "-" ]; then
    continue; # silently ignore unset targets
  fi
  if [ ! -d $f/target-$1 ]; then
    if [ ! -d target-cdk-staging ]; then
      continue; # silently ignore unbuilt facilities
    fi
  fi
  [ -n "$verbose" ] && echo Processing the '"'$ff'"' facility
  # Make links to main programs
  mains=$(find $f -name '*_main.c' -o -name '*_main.cxx' | sed 's-^.*/\([^/]*\)_main\..*$-\1-')
  for m in $mains; do
    exe=$f/target-$1/$m
    if [ ! -e $exe ]; then
      exe=$(find target-cdk-staging/ -name $m 2>/dev/null | grep $1 || :)
      if [ -z "$exe" ]; then
        if [ "$4" == "" ]; then
          echo Executable $m not found in $f/target-$1/$m nor target-cdk-staging/\*\*/$m
        fi
        continue
      fi
    fi
    make_filtered_link $exe exports/bin/$1/$m main
  done

  # Make links to facility libraries
  foundlib=
  if [ "$OCPI_DYNAMIC" == 1 ] ; then
    suffixes=".$dylib"
  else
    suffixes="_s.$dylib .a"
  fi
  for s in $suffixes; do
    lib=lib$2$libname$s
    libpath=$f/target-$1/$lib
    if [ ! -e $libpath ]; then
      libpath=target-cdk-staging/lib/$1/$lib
      if [ ! -e $libpath ]; then
        continue
      fi
    fi
    foundlib=$libpath
    make_filtered_link $libpath exports/lib/$1/$lib library
  done
  if [ "$foundlib" = "" ]; then
     if [ "$4" == "" ]; then
       echo Library $libname not found in $f/target-$1/\* nor target-cdk-staging/lib/$1/\*
     fi
#    exit 1
  fi
  # Make links to facility scripts
  shopt -s nullglob
  for s in $f/scripts/*; do
    script=$(basename $s)
    make_filtered_link $f/scripts/$script exports/scripts/$script scripts
  done

  # Make links to API include files
  for i in $(find $f -name '*Api.h*'); do
    make_filtered_link $i exports/include/aci/$(basename $i) include
  done
done
# Add hdl platforms
[ -n "$verbose" ] && echo Processing hdl platforms
for p in hdl/platforms/*; do
  name=$(basename $p)
  if [ -d $p -a -f $p/Makefile -a -f $p/$(basename $p).xml ]; then
    make_filtered_link $p/lib exports/lib/platforms/$name platform
  fi
done
# If this project has platforms:
#   Export the lib subdir of each platform
#   Export each platform's .mk file in a mk subdir for bootstrapping
if [ -d hdl/platforms ]; then
  for d in hdl/platforms/*; do
    p=$(basename $d)
    if [ -f hdl/platforms/$p/$p.mk ]; then
      make_filtered_link hdl/platforms/$p/lib exports/lib/platforms/$p platform
      make_filtered_link hdl/platforms/$p/$p.mk exports/lib/platforms/mk/$p.mk platform
    fi
  done
fi

# Add rcc platforms
[ -n "$verbose" ] && echo Processing rcc platforms
for p in rcc/platforms/*; do
  name=$(basename $p)
  make_filtered_link $p exports/lib/rcc/platforms/$name rcc-platform
done

# Add component libraries at top level and under hdl
[ -n "$verbose" ] && echo Processing component libraries
for d in components components/* hdl/*; do
  [ ! -d $d -o  ! -f $d/Makefile ] && continue
  egrep -q '^[ 	]*include[ 	]*.*/include/(lib|library).mk' $d/Makefile || continue
  make_filtered_link $d/lib exports/lib/$(basename $d) component
done

[ -n "$verbose" ] && echo Processing hdl primitives
# Add hdl primitives: they must be there before they are built
# since they depend on each other
if [ -d hdl/primitives -a -f hdl/primitives/Makefile ]; then
  for p in hdl/primitives/*; do
    [ ! -d $p -o ! -f $p/Makefile ] && continue
    grep -q '^[ 	]*include[ 	]*.*/include/hdl/hdl-.*\.mk' $p/Makefile || continue
    name=$(basename $p)
    make_filtered_link hdl/primitives/lib/${name} exports/lib/hdl/$name primitive
    grep -q '^[ 	]*include[ 	]*.*/include/hdl/hdl-core.*\.mk' $p/Makefile || continue
    make_filtered_link hdl/primitives/lib/${name}_bb exports/lib/hdl/${name}_bb primitive
  done
fi

# Add the ad-hoc export links
set -f
[ -n "$verbose" ] && echo Processing additions
for a in $additions; do
  declare -a both=($(echo $a | tr : ' '))
  [[ $a == *\<target\>* && $1 == - ]] && continue
  rawsrc=${both[0]//<target>/$1}
  set +f
  # old way letting shell default glob do the work:
  # for src in $rawsrc; do
  targets=$(match_pattern "$rawsrc")
  for src in $targets; do
  if [ -e $src ]; then
    dir=exports/${both[1]//<target>/$1}
    base=$(basename $src)
    after=
    if [[ ${both[1]} =~ /$ || ${both[1]} == "" ]]; then
      after=$base
    else
      # export link has a file name, perhaps replace the suffix
      suff=$(echo $base | sed -n '/\./s/.*\(\.[^.]*\)$/\1/p')
      dir=${dir//<suffix>/$suff}
    fi
    make_relative_link $src $dir$after
  else
    if [ "$3" == "" ]; then
      echo Warning: link source $src does not '(yet?)' exist.
    fi
  fi
  done
  set -f
done

# Move around the binaries to keep the main directory clean (only relevent in autotools mode)
set +f
if [ "x$1" != "x-" ]; then
  for dir in ctests xfer_tests utils; do
    if [ -d target-cdk-staging/bin/$1/${dir} ]; then
      for file in target-cdk-staging/bin/$1/${dir}/*; do
        rm -f exports/bin/$1/$(basename ${file})
        mkdir -p exports/bin/$1/${dir}
        make_relative_link ${file} exports/bin/$1/${dir}/$(basename ${file})
      done
    fi
  done
fi
